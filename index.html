<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YUGY.ORG - ë„ë©´ ì†Œìƒìˆ  ê²Œì„</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; }
    #ui-container {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255, 255, 255, 0.92);
      padding: 14px; border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.12);
      width: 340px;
      z-index: 10;
    }
    textarea { width: 100%; height: 140px; margin: 8px 0 10px; font-size: 12px; }
    button {
      width: 100%; padding: 10px; background: #007bff; color: white;
      border: none; border-radius: 6px; cursor: pointer; font-weight: bold;
    }
    button:hover { background: #0056b3; }
    #info { margin-top: 10px; font-size: 12px; color: #444; line-height: 1.35; }
    .hint { font-size: 11px; color: #666; margin-top: 6px; }
    kbd { background:#f3f3f3; border:1px solid #ddd; border-bottom-width:2px; padding:1px 6px; border-radius:6px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="ui-container">
    <h3>ğŸ  ë„ë©´ ì†Œìƒìˆ  ì‹œë®¬ë ˆì´í„°</h3>
    <div class="hint">ì—‘ì…€ì—ì„œ í‘œ ë²”ìœ„(íƒ­ìœ¼ë¡œ ë³µì‚¬ë˜ëŠ” í˜•íƒœ)ë¥¼ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ê³  Build!</div>

    <textarea id="dataInput" placeholder="ì˜ˆ)
1	í˜„ê´€	5.3	2.4	12.72	12.72	15.4	2.3	35.42
2	ë°©1	2.4	2.4	5.76	5.76	9.6	2.3	22.08"></textarea>

    <button id="buildBtn">ë„ë©´ ìƒì„±í•˜ê¸° (Build)</button>

    <div id="info">
      âœ… <kbd>Shift</kbd> ëˆ„ë¥´ê³  ë“œë˜ê·¸: ì¡°ê° ì´ë™(í¼ì¦ ëª¨ë“œ)<br/>
      âœ… ë§ˆìš°ìŠ¤ ì™¼ìª½: íšŒì „ / ì˜¤ë¥¸ìª½: ì´ë™ / íœ : ì¤Œ<br/>
      âœ… <kbd>G</kbd>: ì •ë‹µ ìœ ë ¹(ìë¦¬) í‘œì‹œ/ìˆ¨ê¸°ê¸°<br/>
      âœ… ê°€ê¹Œì´ ë†“ìœ¼ë©´ ìë™ ìŠ¤ëƒ…(ì ê¸ˆ)
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DragControls } from 'three/addons/controls/DragControls.js';

    // ====== ë¬´ëŒ€ ì„¸íŒ… ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(12, 12, 16);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
    dirLight.position.set(50, 80, 50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const gridHelper = new THREE.GridHelper(120, 120);
    scene.add(gridHelper);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ====== í¼ì¦ ì„¤ì • ======
    const WALL_THICKNESS_M = 0.12;  // 120mm
    const SNAP_DIST = 0.35;         // ìŠ¤ëƒ… í—ˆìš© ê±°ë¦¬(ë¯¸í„° ë‹¨ìœ„ ëŠë‚Œ)
    const TARGET_ROW_LIMIT = 22;    // ì •ë‹µ ë ˆì´ì•„ì›ƒ í•œ ì¤„ í­
    const GAP = 0.35;              // ì¡°ê° ê°„ê²©

    let shiftDown = false;
    window.addEventListener('keydown', (e) => { if (e.key === 'Shift') shiftDown = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'Shift') shiftDown = false; });

    let ghostsVisible = true;
    let pieces = [];   // ì›€ì§ì´ëŠ” ì¡°ê°(ë°© ê·¸ë£¹)
    let ghosts = [];   // ì •ë‹µ ìë¦¬(ìœ ë ¹)
    let dragControls = null;

    // ====== ìœ í‹¸: íƒ­/ì½¤ë§ˆ ë¶„ë¦¬ ======
    function splitCols(line) {
      const t = (line || '').trim();
      if (!t) return null;
      if (t.includes('ê³µê°„ID') || t.includes('ê³µê°„ëª…')) return null;
      const cols = t.includes('\t') ? t.split('\t') : t.split(',');
      return cols.map(c => (c || '').trim());
    }

    function colorFromName(name) {
      let h = 0;
      for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) >>> 0;
      const hex = (h & 0xFFFFFF).toString(16).padStart(6, '0');
      return `#${hex}`;
    }

    function makeLabelSprite(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pad = 18;
      ctx.font = 'bold 22px Malgun Gothic';
      const w = Math.ceil(ctx.measureText(text).width) + pad * 2;
      const h = 48;
      canvas.width = w; canvas.height = h;

      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#111';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, pad, h / 2);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(w / 140, h / 140, 1);
      return sp;
    }

    function clearAll() {
      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = [];
      ghosts = [];
      if (dragControls) { dragControls.dispose(); dragControls = null; }
    }

    // ë°© ê·¸ë£¹: ë°”ë‹¥+ì²œì¥+ë²½4
    function makeRoomGroup({ id, name, w_m, d_m, wallH_m }) {
      const group = new THREE.Group();

      const w = w_m;           // world = m
      const d = d_m;
      const H = wallH_m || 2.3;
      const T = WALL_THICKNESS_M;

      const col = new THREE.Color(colorFromName(name));

      // ë°”ë‹¥
      const floorGeo = new THREE.PlaneGeometry(w, d);
      const floorMat = new THREE.MeshStandardMaterial({ color: col, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0.01;
      floor.receiveShadow = true;
      group.add(floor);

      // ì²œì¥(ë°˜íˆ¬ëª…)
      const ceilMat = new THREE.MeshStandardMaterial({ color: col, side: THREE.DoubleSide, transparent: true, opacity: 0.25 });
      const ceiling = new THREE.Mesh(floorGeo.clone(), ceilMat);
      ceiling.rotation.x = -Math.PI / 2;
      ceiling.position.y = H;
      group.add(ceiling);

      // ë²½ 4ê°œ(ì„œ ìˆëŠ” ë²½)
      const wallMat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.65 });

      // ê°€ë¡œë²½ 2ê°œ
      const wallWGeo = new THREE.BoxGeometry(w, H, T);
      const w1 = new THREE.Mesh(wallWGeo, wallMat);
      w1.position.set(0, H/2, -d/2);
      w1.castShadow = true; w1.receiveShadow = true;
      group.add(w1);

      const w2 = w1.clone();
      w2.position.set(0, H/2, d/2);
      group.add(w2);

      // ì„¸ë¡œë²½ 2ê°œ
      const wallDGeo = new THREE.BoxGeometry(d, H, T);
      const w3 = new THREE.Mesh(wallDGeo, wallMat);
      w3.rotation.y = Math.PI / 2;
      w3.position.set(-w/2, H/2, 0);
      w3.castShadow = true; w3.receiveShadow = true;
      group.add(w3);

      const w4 = w3.clone();
      w4.position.set(w/2, H/2, 0);
      group.add(w4);

      // ë¼ë²¨
      const label = makeLabelSprite(`${name} (${w_m}Ã—${d_m})`);
      label.position.set(0, H + 0.18, 0);
      group.add(label);

      group.userData = {
        id, name,
        w, d, H,
        locked: false,
        targetPos: new THREE.Vector3(0, 0, 0)
      };

      return group;
    }

    function makeGhost(roomGroup) {
      const { w, d } = roomGroup.userData;
      const geo = new THREE.PlaneGeometry(w, d);
      const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.10, side: THREE.DoubleSide });
      const g = new THREE.Mesh(geo, mat);
      g.rotation.x = -Math.PI / 2;
      g.position.y = 0.005;
      return g;
    }

    // ì •ë‹µ ìë¦¬ ìë™ ë°°ì¹˜(í–‰/ì—´)
    function layoutTargets(groups) {
      let x = 0, z = 0;
      let rowDepth = 0;

      for (const g of groups) {
        const w = g.userData.w;
        const d = g.userData.d;

        if (x + w > TARGET_ROW_LIMIT) {
          x = 0;
          z += rowDepth + GAP;
          rowDepth = 0;
        }
        const tx = x + w / 2;
        const tz = z + d / 2;
        g.userData.targetPos.set(tx, 0, tz);

        x += w + GAP;
        rowDepth = Math.max(rowDepth, d);
      }
    }

    function scatterPieces(groups) {
      // ì¡°ê°ì€ ì •ë‹µì—ì„œ ì‚´ì§ ë–¨ì–´ì§„ ê³³ì— ëœë¤ ë°°ì¹˜
      for (const g of groups) {
        const t = g.userData.targetPos;
        g.position.set(
          t.x + (Math.random() - 0.5) * 10,
          0,
          t.z + 5 + (Math.random() - 0.5) * 10
        );
      }
    }

    function lockPiece(g) {
      g.userData.locked = true;
      // ì ê¸´ ëŠë‚Œ: ì‚´ì§ ë°ê²Œ
      g.traverse(obj => {
        if (obj.isMesh && obj.material) {
          obj.material.emissive = new THREE.Color(0x111111);
          obj.material.emissiveIntensity = 0.6;
        }
      });
    }

    function trySnap(g) {
      const t = g.userData.targetPos;
      const dist = g.position.distanceTo(t);
      if (dist < SNAP_DIST) {
        g.position.copy(t);
        lockPiece(g);
        return true;
      }
      return false;
    }

    function refreshDragControls() {
      if (dragControls) { dragControls.dispose(); dragControls = null; }
      const unlocked = pieces.filter(p => !p.userData.locked);
      dragControls = new DragControls(unlocked, camera, renderer.domElement);
      dragControls.transformGroup = true;
      dragControls.enabled = false;

      dragControls.addEventListener('dragstart', () => { controls.enabled = false; });
      dragControls.addEventListener('drag', (e) => { e.object.position.y = 0; });
      dragControls.addEventListener('dragend', (e) => {
        controls.enabled = true;
        e.object.position.y = 0;
        if (!e.object.userData.locked) {
          const snapped = trySnap(e.object);
          if (snapped) refreshDragControls();
        }
      });
    }

    // Shift ëˆŒë €ì„ ë•Œë§Œ ë“œë˜ê·¸ í™œì„±í™”
    window.addEventListener('pointerdown', () => { if (dragControls) dragControls.enabled = shiftDown; });
    window.addEventListener('pointerup', () => { if (dragControls) dragControls.enabled = false; });

    // Gí‚¤: ìœ ë ¹ í† ê¸€
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'g') {
        ghostsVisible = !ghostsVisible;
        ghosts.forEach(g => g.visible = ghostsVisible);
      }
    });

    // âœ… í•µì‹¬: íƒ­ ë°ì´í„°(9ì—´) ë¶™ì—¬ë„£ê¸° -> ë°© ì¡°ê° ìƒì„± -> ì •ë‹µ ìœ ë ¹ ê¹”ê¸° -> í¼ì¦ ëª¨ë“œ
    function buildFromData() {
      clearAll();

      const input = document.getElementById('dataInput').value || '';
      const lines = input.split(/\r?\n/);

      const groups = [];

      for (const line of lines) {
        const cols = splitCols(line);
        if (!cols) continue;

        // í˜•ì‹: [0]ê³µê°„ID [1]ê³µê°„ëª… [2]ê°€ë¡œ(m) [3]ì„¸ë¡œ(m) ... [7]ë²½ë†’ì´(m)
        if (cols.length >= 8 && !isNaN(Number(cols[0])) && cols[1]) {
          const id = cols[0];
          const name = cols[1];
          const w_m = parseFloat(cols[2]);
          const d_m = parseFloat(cols[3]);
          const wallH_m = parseFloat(cols[7]) || 2.3;

          if ([w_m, d_m].every(Number.isFinite)) {
            groups.push(makeRoomGroup({ id, name, w_m, d_m, wallH_m }));
          }
        }
      }

      if (groups.length === 0) {
        alert('ë¶™ì—¬ë„£ì€ ë°ì´í„°ì—ì„œ ë°© ì •ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆì–´ìš”. (íƒ­ êµ¬ë¶„ / 9ì—´ í˜•ì‹ì¸ì§€ í™•ì¸)');
        return;
      }

      // ì •ë‹µ ìë¦¬ ë°°ì¹˜
      layoutTargets(groups);

      // ìœ ë ¹ ê¹”ê¸°
      for (const g of groups) {
        const ghost = makeGhost(g);
        ghost.position.x = g.userData.targetPos.x;
        ghost.position.z = g.userData.targetPos.z;
        ghost.visible = ghostsVisible;
        scene.add(ghost);
        ghosts.push(ghost);
      }

      // ì¡°ê° ì¶”ê°€ + ì„ê¸°
      for (const g of groups) {
        scene.add(g);
        pieces.push(g);
      }
      scatterPieces(pieces);

      // ë“œë˜ê·¸ ì„¸íŒ…
      refreshDragControls();

      // ì¹´ë©”ë¼ê°€ ì „ì²´ê°€ ë³´ì´ë„ë¡ target ê·¼ì²˜ë¡œ
      controls.target.set(TARGET_ROW_LIMIT / 2, 0, 3);
      controls.update();
    }

    document.getElementById('buildBtn').addEventListener('click', buildFromData);

    // ë Œë” ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ì°½ í¬ê¸° ëŒ€ì‘
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
