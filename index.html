<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YUGY.ORG - ë„ë©´ ì†Œìƒìˆ  ê²Œì„</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; }
    #ui-container {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255, 255, 255, 0.92);
      padding: 14px; border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.12);
      width: 360px;
      z-index: 10;
    }
    textarea { width: 100%; height: 150px; margin: 8px 0 10px; font-size: 12px; }
    button {
      width: 100%; padding: 10px; background: #007bff; color: white;
      border: none; border-radius: 6px; cursor: pointer; font-weight: bold;
    }
    button:hover { background: #0056b3; }
    #info { margin-top: 10px; font-size: 12px; color: #444; line-height: 1.35; }
    .hint { font-size: 11px; color: #666; margin-top: 6px; }
    kbd { background:#f3f3f3; border:1px solid #ddd; border-bottom-width:2px; padding:1px 6px; border-radius:6px; }

    /* âœ… íˆ´íŒ */
    #tooltip{
      position: fixed;
      z-index: 9999;
      display: none;
      pointer-events: none;
      background: rgba(20,20,20,0.92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.4;
      max-width: 340px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(4px);
    }
    #tooltip b{ font-size: 15px; }
    #tooltip .small{ opacity: 0.85; font-size: 12px; margin-top: 6px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="ui-container">
    <h3>ğŸ  ë„ë©´ ì†Œìƒìˆ  ì‹œë®¬ë ˆì´í„°</h3>
    <div class="hint">ì—‘ì…€ì—ì„œ í‘œ ë²”ìœ„ë¥¼ ê·¸ëŒ€ë¡œ ë³µì‚¬(íƒ­ìœ¼ë¡œ ë¶™ëŠ” í˜•íƒœ) â†’ ì—¬ê¸°ì— ë¶™ì—¬ë„£ê¸° â†’ Build</div>

    <textarea id="dataInput" placeholder="ì˜ˆ)
1	í˜„ê´€	5.3	2.4	12.72	12.72	15.4	2.3	35.42
2	ë°©1	2.4	2.4	5.76	5.76	9.6	2.3	22.08"></textarea>

    <button id="buildBtn">ë„ë©´ ìƒì„±í•˜ê¸° (Build)</button>

    <div id="info">
      âœ… <kbd>Shift</kbd> + í´ë¦­ë“œë˜ê·¸: ë°© ì¡°ê° ì´ë™(í¼ì¦)<br/>
      âœ… ë§ˆìš°ìŠ¤ ì™¼ìª½: íšŒì „ / ì˜¤ë¥¸ìª½: ì´ë™ / íœ : ì¤Œ<br/>
      âœ… <kbd>G</kbd>: ì •ë‹µ ìœ ë ¹(ìë¦¬) í‘œì‹œ/ìˆ¨ê¸°ê¸°<br/>
      âœ… ìœ ë ¹ ê°€ê¹Œì´ ë†“ìœ¼ë©´ ìë™ ìŠ¤ëƒ…(ì ê¸ˆ)<br/>
      âœ… ë°©ì— ë§ˆìš°ìŠ¤ ì˜¬ë¦¬ë©´ ë©´ì /ê¸¸ì´/ë²½ë©´ì  íˆ´íŒ í‘œì‹œ
    </div>
  </div>

  <!-- âœ… íˆ´íŒ DOM -->
  <div id="tooltip"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ====== ë¬´ëŒ€ ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(12, 12, 16);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
    dirLight.position.set(50, 80, 50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const gridHelper = new THREE.GridHelper(120, 120);
    scene.add(gridHelper);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ====== í¼ì¦ ì„¤ì • ======
    const WALL_THICKNESS = 0.12;   // m (120mm)
    const SNAP_DIST = 0.35;        // m
    const ROW_LIMIT = 22;          // ì •ë‹µ ë°°ì¹˜ í•œ ì¤„ í­
    const GAP = 0.35;              // ì¡°ê° ê°„ê²©

    // ìƒ‰ìƒ íŒ”ë ˆíŠ¸(í™•ì‹¤íˆ ë‹¤ë¥´ê²Œ!)
    const PALETTE = [
      "#ff6b6b","#feca57","#1dd1a1","#54a0ff","#5f27cd",
      "#48dbfb","#c8d6e5","#00d2d3","#ff9f43","#ee5253",
      "#10ac84","#2e86de","#341f97","#576574","#f368e0"
    ];

    let shiftDown = false;
    window.addEventListener('keydown', (e) => { if (e.key === 'Shift') shiftDown = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'Shift') shiftDown = false; });

    let ghostsVisible = true;

    // í¼ì¦ ì˜¤ë¸Œì íŠ¸
    let pieces = [];        // ë°© ê·¸ë£¹
    let ghostPlanes = [];   // ì •ë‹µ ìœ ë ¹
    let hitMeshes = [];     // í´ë¦­/í˜¸ë²„ ì¡ëŠ” íˆ¬ëª… ë©”ì‰¬(ì„ íƒìš©)

    // ë“œë˜ê·¸(ì§ì ‘ êµ¬í˜„)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y=0 í‰ë©´
    let dragging = false;
    let draggedGroup = null;
    let dragOffset = new THREE.Vector3();

    // âœ… íˆ´íŒ
    const tooltip = document.getElementById('tooltip');
    function fmt(n, digits=2){
      if (!Number.isFinite(n)) return '-';
      return n.toFixed(digits);
    }
    function hideTooltip(){
      tooltip.style.display = 'none';
    }
    function showTooltip(e, group){
      const m = group.userData.metrics;
      if (!m) return;

      tooltip.style.display = 'block';

      // UI íŒ¨ë„(ì™¼ìª½ 360px) ìœ„ë¡œ íˆ´íŒì´ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì˜¤ë¥¸ìª½ì— ê¸°ë³¸ ë°°ì¹˜
      const baseLeft = Math.max(e.clientX + 14, 380);
      const baseTop  = e.clientY + 14;

      tooltip.style.left = baseLeft + 'px';
      tooltip.style.top  = baseTop + 'px';

      tooltip.innerHTML = `
        <b>${group.userData.name}</b><br/>
        ê°€ë¡œ ${fmt(m.width_m)} m Ã— ì„¸ë¡œ ${fmt(m.depth_m)} m Ã— ë†’ì´ ${fmt(m.height_m)} m<br/>
        ë°”ë‹¥ ${fmt(m.floor_m2)} ã¡ / ì²œì¥ ${fmt(m.ceiling_m2)} ã¡<br/>
        ë‘˜ë ˆ ${fmt(m.perimeter_m)} m / ë²½ë©´ì  ${fmt(m.wall_m2)} ã¡
        <div class="small">â€» ì´ ê°’ë“¤ì€ ì—ë„ˆì§€/ë¬¼ëŸ‰ ì‚°ì¶œì— ë°”ë¡œ ì“°ë ¤ê³  room.metricsì— ì €ì¥ë¼ ìˆì–´ìš”.</div>
      `;
    }

    function splitCols(line) {
      const t = (line || '').trim();
      if (!t) return null;
      if (t.includes('ê³µê°„ID') || t.includes('ê³µê°„ëª…')) return null;

      if (t.includes('\t')) return t.split('\t').map(s => s.trim());
      if (t.includes(',')) return t.split(',').map(s => s.trim());
      return t.split(/\s+/).map(s => s.trim());
    }

    // âœ… ë¼ë²¨ í¬ê²Œ + ì„ ëª…í•˜ê²Œ
    function makeLabelSprite(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pad = 24;

      ctx.font = 'bold 34px Malgun Gothic';
      const w = Math.ceil(ctx.measureText(text).width) + pad * 2;
      const h = 72;
      canvas.width = w; canvas.height = h;

      // ì„ ëª…ë„ í–¥ìƒ
      ctx.imageSmoothingEnabled = true;

      ctx.fillStyle = 'rgba(255,255,255,0.93)';
      ctx.fillRect(0, 0, w, h);

      ctx.fillStyle = '#111';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, pad, h / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sp = new THREE.Sprite(mat);

      // í™”ë©´ì—ì„œ í¬ê²Œ ë³´ì´ê²Œ
      sp.scale.set(w / 80, h / 80, 1);
      return sp;
    }

    function clearAll() {
      pieces.forEach(g => scene.remove(g));
      ghostPlanes.forEach(g => scene.remove(g));

      pieces = [];
      ghostPlanes = [];
      hitMeshes = [];

      dragging = false;
      draggedGroup = null;
      hideTooltip();
    }

    function makeRoomGroup({ id, name, w_m, d_m, wallH_m, color }) {
      const group = new THREE.Group();

      const w = w_m;
      const d = d_m;
      const H = wallH_m || 2.3;
      const T = WALL_THICKNESS;

      // ë°”ë‹¥
      const floorGeo = new THREE.PlaneGeometry(w, d);
      const floorMat = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0.01;
      floor.receiveShadow = true;
      group.add(floor);

      // ì²œì¥(ë°˜íˆ¬ëª…)
      const ceilMat = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity: 0.22 });
      const ceiling = new THREE.Mesh(floorGeo.clone(), ceilMat);
      ceiling.rotation.x = -Math.PI / 2;
      ceiling.position.y = H;
      group.add(ceiling);

      // ë²½ 4ê°œ
      const wallMat = new THREE.MeshStandardMaterial({ color, roughness: 0.65 });

      const wallWGeo = new THREE.BoxGeometry(w, H, T);
      const w1 = new THREE.Mesh(wallWGeo, wallMat);
      w1.position.set(0, H/2, -d/2);
      w1.castShadow = true; w1.receiveShadow = true;
      group.add(w1);

      const w2 = w1.clone();
      w2.position.set(0, H/2, d/2);
      group.add(w2);

      const wallDGeo = new THREE.BoxGeometry(d, H, T);
      const w3 = new THREE.Mesh(wallDGeo, wallMat);
      w3.rotation.y = Math.PI / 2;
      w3.position.set(-w/2, H/2, 0);
      w3.castShadow = true; w3.receiveShadow = true;
      group.add(w3);

      const w4 = w3.clone();
      w4.position.set(w/2, H/2, 0);
      group.add(w4);

      // ë¼ë²¨
      const label = makeLabelSprite(`${name} (${w_m}Ã—${d_m})`);
      label.position.set(0, H + 0.35, 0);
      group.add(label);

      // âœ… ì„ íƒ/í˜¸ë²„ìš© â€œíˆ¬ëª… íˆíŠ¸ë°•ìŠ¤â€
      // ì‚´ì§ ë” í¬ê²Œ ë§Œë“¤ì–´ì„œ ì¡ê¸° í¸í•˜ê²Œ!
      const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, side: THREE.DoubleSide });
      const hit = new THREE.Mesh(new THREE.PlaneGeometry(w * 1.02, d * 1.02), hitMat);
      hit.rotation.x = -Math.PI / 2;
      hit.position.y = 0.03;
      hit.userData.dragGroup = group;
      group.add(hit);
      hitMeshes.push(hit);

      // âœ… ì—ë„ˆì§€/ë¬¼ëŸ‰ ì‚°ì¶œìš© ìˆ˜ì¹˜ ì €ì¥
      const floorArea = w * d;
      const ceilingArea = floorArea;
      const perimeter = 2 * (w + d);
      const wallArea = perimeter * H;

      group.userData = {
        id, name, w, d, H,
        locked: false,
        targetPos: new THREE.Vector3(0,0,0),
        baseColor: color,
        metrics: {
          width_m: w,
          depth_m: d,
          height_m: H,
          floor_m2: floorArea,
          ceiling_m2: ceilingArea,
          perimeter_m: perimeter,
          wall_m2: wallArea
        }
      };

      return group;
    }

    function makeGhostFor(group) {
      const { w, d } = group.userData;
      const geo = new THREE.PlaneGeometry(w, d);
      const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.10, side: THREE.DoubleSide });
      const ghost = new THREE.Mesh(geo, mat);
      ghost.rotation.x = -Math.PI / 2;
      ghost.position.y = 0.005;
      return ghost;
    }

    function layoutTargets(groups) {
      let x = 0, z = 0;
      let rowDepth = 0;
      for (const g of groups) {
        const w = g.userData.w;
        const d = g.userData.d;
        if (x + w > ROW_LIMIT) {
          x = 0;
          z += rowDepth + GAP;
          rowDepth = 0;
        }
        g.userData.targetPos.set(x + w/2, 0, z + d/2);
        x += w + GAP;
        rowDepth = Math.max(rowDepth, d);
      }
    }

    function scatterPieces(groups) {
      for (const g of groups) {
        const t = g.userData.targetPos;
        g.position.set(
          t.x + (Math.random() - 0.5) * 10,
          0,
          t.z + 5 + (Math.random() - 0.5) * 10
        );
      }
    }

    function lockPiece(group) {
      group.userData.locked = true;
      group.traverse(obj => {
        if (obj.isMesh && obj.material && obj.material.emissive !== undefined) {
          obj.material.emissive = new THREE.Color(0x111111);
          obj.material.emissiveIntensity = 0.6;
        }
      });
    }

    function trySnap(group) {
      const t = group.userData.targetPos;
      const dist = group.position.distanceTo(t);
      if (dist < SNAP_DIST) {
        group.position.copy(t);
        lockPiece(group);
        return true;
      }
      return false;
    }

    function setMouseFromEvent(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    }

    // âœ… Shift + í´ë¦­ë“œë˜ê·¸ë¡œ â€œë°© ê·¸ë£¹â€ ì´ë™
    renderer.domElement.addEventListener('pointerdown', (e) => {
      if (!shiftDown) return;

      setMouseFromEvent(e);
      raycaster.setFromCamera(mouse, camera);

      const hits = raycaster.intersectObjects(hitMeshes, true);
      if (!hits.length) return;

      const hit = hits[0].object;
      const g = hit.userData.dragGroup;
      if (!g || g.userData.locked) return;

      dragging = true;
      draggedGroup = g;
      controls.enabled = false;
      hideTooltip();

      const p = new THREE.Vector3();
      raycaster.ray.intersectPlane(dragPlane, p);
      dragOffset.copy(p).sub(draggedGroup.position);
    });

    // âœ… ë“œë˜ê·¸ & í˜¸ë²„ íˆ´íŒ
    renderer.domElement.addEventListener('pointermove', (e) => {
      // ë“œë˜ê·¸ ì¤‘ì´ë©´ ì´ë™ë§Œ
      if (dragging && draggedGroup) {
        setMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);

        const p = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, p);

        draggedGroup.position.copy(p.sub(dragOffset));
        draggedGroup.position.y = 0;
        return;
      }

      // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ˆë©´: í˜¸ë²„ íˆ´íŒ
      setMouseFromEvent(e);
      raycaster.setFromCamera(mouse, camera);

      const hits = raycaster.intersectObjects(hitMeshes, true);
      if (!hits.length) { hideTooltip(); return; }

      const hit = hits[0].object;
      const g = hit.userData.dragGroup;
      if (!g) { hideTooltip(); return; }

      showTooltip(e, g);
    });

    renderer.domElement.addEventListener('pointerup', () => {
      if (!dragging || !draggedGroup) return;

      dragging = false;
      controls.enabled = true;

      if (!draggedGroup.userData.locked) {
        trySnap(draggedGroup);
      }
      draggedGroup = null;
    });

    // Gí‚¤: ìœ ë ¹ í† ê¸€
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'g') {
        ghostsVisible = !ghostsVisible;
        ghostPlanes.forEach(g => g.visible = ghostsVisible);
      }
    });

    function buildFromData() {
      clearAll();

      const input = document.getElementById('dataInput').value || '';
      const lines = input.split(/\r?\n/);

      const groups = [];

      for (const line of lines) {
        const cols = splitCols(line);
        if (!cols) continue;

        // í˜•ì‹: [0]ê³µê°„ID [1]ê³µê°„ëª… [2]ê°€ë¡œ(m) [3]ì„¸ë¡œ(m) ... [7]ë²½ë†’ì´(m)
        if (cols.length >= 8 && !isNaN(Number(cols[0])) && cols[1]) {
          const id = parseInt(cols[0], 10);
          const name = cols[1];
          const w_m = parseFloat(cols[2]);
          const d_m = parseFloat(cols[3]);
          const wallH_m = parseFloat(cols[7]) || 2.3;

          if ([w_m, d_m].every(Number.isFinite)) {
            const color = new THREE.Color(PALETTE[(id - 1) % PALETTE.length]);
            groups.push(makeRoomGroup({ id, name, w_m, d_m, wallH_m, color }));
          }
        }
      }

      if (groups.length === 0) {
        alert('ë¶™ì—¬ë„£ì€ ë°ì´í„°ì—ì„œ ë°© ì •ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆì–´ìš”. (íƒ­ êµ¬ë¶„ / 9ì—´ í˜•ì‹ì¸ì§€ í™•ì¸)');
        return;
      }

      layoutTargets(groups);

      // ìœ ë ¹ ê¹”ê¸°
      for (const g of groups) {
        const ghost = makeGhostFor(g);
        ghost.position.x = g.userData.targetPos.x;
        ghost.position.z = g.userData.targetPos.z;
        ghost.visible = ghostsVisible;
        scene.add(ghost);
        ghostPlanes.push(ghost);
      }

      // ì¡°ê° ì¶”ê°€ + ì„ê¸°
      for (const g of groups) {
        scene.add(g);
        pieces.push(g);
      }
      scatterPieces(pieces);

      // ì¹´ë©”ë¼ ì‹œì  ì •ë¦¬
      controls.target.set(ROW_LIMIT / 2, 0, 3);
      controls.update();
    }

    document.getElementById('buildBtn').addEventListener('click', buildFromData);

    // ë Œë” ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
